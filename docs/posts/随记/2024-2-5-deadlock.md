---
tags:
    - 笔记
    - 日常小笔记
    - 多线程
img: https://cdn.jsdelivr.net/gh/open17/Pic/img/202402050154255.png
desc: 日常小笔记系列
---

# 死锁
:::tip 目录
[[toc]]
:::

死锁是进程死锁的简称，是由Dijkstra(没错还是他)于1965年首先提出来的。
它是计算机系统乃至并发程序设计中最难处理的问题之一

## 形成条件
死锁出现必须满足以下四个条件
- 互斥性：资源是可分配的，但只能由一个进程占用。
- 不剥夺条件：一个进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- 请求和保持：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- 环路等待：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

通俗点来说就是:
1. 一个物品(资源)一段时间内只能单人使用
2. 另外一个人想用此时别人在使用的物品时，只能等待,不能强制夺取
3. 在拿到新的物品之前不放手现在的物品
4. A等B放手,B等C放手,...,最后X等A放手形成循环

## 避免出现
显然破坏四个条件中的任意一个都可以解决

### 方案一 破坏互斥
比如复制n份资源给n个人,但是这样一般开销可能很大,所以一般不采用

### 方案二 破坏环路等待
强制采取不循坏等待的顺序即可

### 方案三 允许剥夺
我们可以设置一个"最长占用时间",如果超时则强制归还

### 方案四 破坏请求和保持
避免线程的贪心,比如规定线程在请求新的资源时,必须释放先所有资源,这样就不存在请求和保持了




## 参考
:::success 参考列表
- [用个通俗的例子讲一讲死锁](https://zhuanlan.zhihu.com/p/26945588)
:::

